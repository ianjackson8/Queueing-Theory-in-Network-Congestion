# if no events in queue OR events occur later than cur time
if len(self.queue.event_queue) == 0 or cur_time < self.queue.event_queue[0].event_time:
    # generate new packet and insert into queue
    packet = Packet(packet_id, cur_time, self.mu, self.theta, self.is_exp_drop)
    print(f"[{cur_time:.4f}] [{len(self.queue.priority_queue)}] Packet {packet_id} ARRIVAL")

    self.queue.insert_packet(packet)

    # log the current time and queue state
    self.queue.log_stats(cur_time)

    # advance sim time and increment packet id
    cur_time += rnd.exponential(1 / self.lmbda)
    packet_id += 1
else:
    # otherwise, process next event
    self.queue.handle_jobs()

# if using TCP Reno, adjust the number of packets to send based on cwnd
if self.use_tcp_reno:
    packets_to_send = int(self.cc.get_cwnd())
else:
    packets_to_send = 1

for _ in range(packets_to_send):
    if packet_id >= n_packet:
        break
    # generate new packet and insert into queue
    packet = Packet(packet_id, cur_time, self.mu, self.theta, self.is_exp_drop)
    print(f"[{cur_time:.4f}] [{len(self.queue.priority_queue)}] Packet {packet_id} ARRIVAL")

    self.queue.insert_packet(packet)

    # log the current time and queue state
    self.queue.log_stats(cur_time)

    # advance sim time and increment packet id
    cur_time += rnd.exponential(1 / self.lmbda)
    packet_id += 1

while self.queue.event_queue and cur_time >= self.queue.event_queue[0].event_time:
    event = self.queue.event_queue[0]

    # process the next event in the queue
    if event.status == PacketStatus.SERVICED:
        if self.use_tcp_reno:
            # handle TCP Reno ACKs
            self.cc.on_ack()
    elif event.status == PacketStatus.DROP:
        if self.use_tcp_reno:
            # handle TCP Reno packet loss
            self.cc.on_loss()
    # process the event
    self.queue.handle_jobs()